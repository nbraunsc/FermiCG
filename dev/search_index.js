var documenterSearchIndex = {"docs":
[{"location":"library/States/#Wavefunction-types","page":"States","title":"Wavefunction types","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Each of the methods implemented in this package use a unique data representation for the wavefunction. These all rely on some kind of hash table lookup, and so the following indexing schemes are defined to make this easier and faster (i.e., implemented using only stack allocated data).","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"List of Indexing types for representing states","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"ClusterConfig\nTuckerConfig\nFockConfig","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"Each of the different wavefunction types map different Index types to data (wavefunction coefficients)","category":"page"},{"location":"library/States/","page":"States","title":"States","text":"TPSCI: ClusteredState: Maps FockConfig → ClusterConfig →  Vector of coefficients (one for each state)\nBST: CompressedTuckerState: Maps FockConfig → TuckerConfig →  Tucker instance representing compressed set of coefficients for that subspace","category":"page"},{"location":"library/States/#Index","page":"States","title":"Index","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Pages = [\"States.md\"]","category":"page"},{"location":"library/States/#Types","page":"States","title":"Types","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Modules = [FermiCG]\nPages   = [\"States.jl\", \n\t\"FockSparse_ElementSparse.jl\",\n\t\"FockSparse_BlockSparse.jl\",\t\n\t\"FockSparse_BlockSparseTucker.jl\", \n\t\"Indexing.jl\"]\nOrder   = [:type]\nDepth\t= 2","category":"page"},{"location":"library/States/#FermiCG.AbstractState","page":"States","title":"FermiCG.AbstractState","text":"Glue different Sparse Vector State types together\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.FockSparseState","page":"States","title":"FermiCG.FockSparseState","text":"\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.ClusteredState","page":"States","title":"FermiCG.ClusteredState","text":"clusters::Vector{Cluster}\ndata::OrderedDict{FockConfig{N}, OrderedDict{ClusterConfig{N}, Vector{T}}}\n\nThis represents an arbitrarily sparse state. E.g., used in TPSCI\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.ClusteredState-Tuple{Any}","page":"States","title":"FermiCG.ClusteredState","text":"ClusteredState(clusters)\n\nConstructor\n\nclusters::Vector{Cluster}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.TuckerState","page":"States","title":"FermiCG.TuckerState","text":"Represents a state in an set of abitrary (yet dense) subspaces of a set of FockConfigs.\n\nv[FockConfig][TuckerConfig] => Dense Tensor E.g., used in n-body Tucker\n\nclusters::Vector{Cluster}\ndata::OrderedDict{FockConfig,OrderedDict{TuckerConfig,Array}}\np_spaces::Vector{ClusterSubspace}\nq_spaces::Vector{ClusterSubspace}\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.TuckerState-Tuple{Array{Cluster,1},Array{FermiCG.ClusterSubspace,1},Array{FermiCG.ClusterSubspace,1},Any,Any}","page":"States","title":"FermiCG.TuckerState","text":"TuckerState(clusters, p_spaces, q_spaces, foi; nroots=1)\n\nConstructor\n\nclusters::Vector{Cluster}\np_spaces::Vector{ClusterSubspace}\nq_spaces::Vector{ClusterSubspace}\nna::Int Number of alpha\nnb::Int Number of beta\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.TuckerState-Tuple{Array{Cluster,1},Array{FermiCG.ClusterSubspace,1},Array{FermiCG.ClusterSubspace,1},OrderedCollections.OrderedDict{FockConfig,Array{FermiCG.TuckerConfig,1}}}","page":"States","title":"FermiCG.TuckerState","text":"TuckerState(clusters, p_spaces, q_spaces, foi; nroots=1)\n\nConstructor to build state directly from a definition of a first order interacting space (or more generic even i suppose)\n\nclusters::Vector{Cluster}\np_spaces::Vector{ClusterSubspace}\nq_spaces::Vector{ClusterSubspace}\nfoi::OrderedDict{FockConfig,Vector{TuckerConfig}} \nnroots\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.CompressedTuckerState","page":"States","title":"FermiCG.CompressedTuckerState","text":"Represents a state in an set of abitrary (yet low-rank) subspaces of a set of FockConfigs. e.g. \n\nv[FockConfig][TuckerConfig] => Tucker Decomposed Tensor\n\nData\n\nclusters::Vector{Cluster}\ndata::OrderedDict{FockConfig,OrderedDict{TuckerConfig,Tucker}}\np_spaces::Vector{ClusterSubspace}\nq_spaces::Vector{ClusterSubspace}\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.CompressedTuckerState-Union{Tuple{FermiCG.TuckerState{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"States","title":"FermiCG.CompressedTuckerState","text":"CompressedTuckerState(ts::TuckerState; thresh=-1, max_number=nothing, verbose=0)\n\nCreate a CompressedTuckerState from a TuckerState \n\nArguments\n\nts::TuckerState\nthresh=-1: discard singular values smaller than thresh\nmax_number=nothing: if != nothing, only keep up to max_number singular vectors per SVD\nverbose=0: print level\n\nReturns\n\nCompressedTuckerState\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.ClusterConfig","page":"States","title":"FermiCG.ClusterConfig","text":"config::NTuple{N,Int16}\n\nIndexes an N dimensional space \n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.FockConfig","page":"States","title":"FermiCG.FockConfig","text":"config::NTuple{N,Tuple{Int16,Int16}}\n\nIndexes a 'Change in fock space'. For instance, if F1 and F2 are distince FockConfig instances,  then TransferConfig is F1-F2.\n\ne.g., config = ((2,3), (2,2), (3,2)) is a 3 cluster configuration with 2, 2, 3 α and 3, 2, 2 β electrons, respectively.  \n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.OperatorConfig","page":"States","title":"FermiCG.OperatorConfig","text":"config::Tuple{FockConfig{N}, FockConfig{N}, T, T}\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.SparseIndex","page":"States","title":"FermiCG.SparseIndex","text":"Abstract index type\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.TransferConfig","page":"States","title":"FermiCG.TransferConfig","text":"config::NTuple{N,Tuple{Int16,Int16}}\n\nIndexes a 'Change in fock space'. For instance, if F1 and F2 are distince FockConfig instances,  then TransferConfig is F1-F2.\n\nThis is mainly used to label individual parts of an operator (Hamiltonian) as they can only enact certain changes in the  Fock space configurations.\n\n\n\n\n\n","category":"type"},{"location":"library/States/#FermiCG.TuckerConfig","page":"States","title":"FermiCG.TuckerConfig","text":"config::NTuple{N,UnitRange{Int}}\n\nIndexes a particular subspace in the tensor product space. Each TuckerConfig instance specifies the entire subspace defined by a set of cluster states (specified by a range) on each cluster.\n\nE.g., \n\n((1:1), (1:1), (1:1)) is simply the ground state CMF state for a 3 cluster systems. \n((2:20), (1:1), (2:20))  are all states where clusters 1 and 2 are excited out of their repsective ground states.\n\n\n\n\n\n","category":"type"},{"location":"library/States/#Methods","page":"States","title":"Methods","text":"","category":"section"},{"location":"library/States/","page":"States","title":"States","text":"Modules = [FermiCG]\nPages   = [\"States.jl\", \n\t\"FockSparse_ElementSparse.jl\",\n\t\"FockSparse_BlockSparse.jl\",\t\n\t\"FockSparse_BlockSparseTucker.jl\", \n\t\"Indexing.jl\"]\nOrder   = [:function]\nDepth\t= 2","category":"page"},{"location":"library/States/#Base.setindex!-Tuple{FermiCG.AbstractState,Any,Any}","page":"States","title":"Base.setindex!","text":"setindex!(s::AbstractState, a::OrderedDict, b)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add_fockconfig!-Union{Tuple{T}, Tuple{FermiCG.AbstractState,Array{Tuple{T,T},1}}} where T<:Integer","page":"States","title":"FermiCG.add_fockconfig!","text":"add_fockconfig!(s::AbstractState, fock::Vector{Tuple{T,T}}) where T<:Integer\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.Multimedia.display-Tuple{ClusteredState}","page":"States","title":"Base.Multimedia.display","text":"Base.display(s::ClusteredState; thresh=1e-3, root=1)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add!-Tuple{ClusteredState,ClusteredState}","page":"States","title":"FermiCG.add!","text":"add!(s1::ClusteredState, s2::ClusteredState)\n\nAdd coeffs in s2 to s1\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add_fockconfig!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},FockConfig{N}}} where R where N where T<:Number","page":"States","title":"FermiCG.add_fockconfig!","text":"add_fockconfig!(s::ClusteredState, fock::FockConfig)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.clip!-Tuple{ClusteredState}","page":"States","title":"FermiCG.clip!","text":"clip!(s::ClusteredState; thresh=1e-5)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.dot-Union{Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,1},ClusteredState{T,N,1}}} where N where T","page":"States","title":"FermiCG.dot","text":"dot(v1::ClusteredState,v2::ClusteredState; r1=1, r2=1)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.dot-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"States","title":"FermiCG.dot","text":"dot(v1::ClusteredState,v2::ClusteredState; r1=1, r2=1)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.get_vector-Tuple{ClusteredState}","page":"States","title":"FermiCG.get_vector","text":"get_vector(s::ClusteredState; root=1)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.get_vectors-Union{Tuple{ClusteredState{T,N,R}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"States","title":"FermiCG.get_vectors","text":"get_vectors(s::ClusteredState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.normalize!-Tuple{FermiCG.AbstractState}","page":"States","title":"FermiCG.normalize!","text":"normalize!(s::AbstractState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.orth!-Union{Tuple{ClusteredState{T,N,R}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"States","title":"FermiCG.orth!","text":"dot(v1::ClusteredState,v2::ClusteredState; r1=1, r2=1)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.print_configs-Tuple{ClusteredState}","page":"States","title":"FermiCG.print_configs","text":"print_configs(s::ClusterState; thresh=1e-3)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.prune_empty_fock_spaces!-Tuple{ClusteredState}","page":"States","title":"FermiCG.prune_empty_fock_spaces!","text":"prune_empty_fock_spaces!(s::ClusteredState)\n\nremove fock_spaces that don't have any configurations \n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.scale!-Tuple{ClusteredState,Any}","page":"States","title":"FermiCG.scale!","text":"scale!(s::ClusteredState,c)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.set_vector!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Array{T,2}}} where R where N where T","page":"States","title":"FermiCG.set_vector!","text":"set_vector!(s::ClusteredState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.zero!-Union{Tuple{ClusteredState{T,N,R}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"States","title":"FermiCG.zero!","text":"zero!(s::ClusteredState)\n\nset all elements to zero\n\n\n\n\n\n","category":"method"},{"location":"library/States/#LinearAlgebra.norm-Tuple{ClusteredState,Any}","page":"States","title":"LinearAlgebra.norm","text":"norm(s::ClusteredState, root)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#LinearAlgebra.norm-Union{Tuple{ClusteredState{T,N,R}}, Tuple{R}, Tuple{N}, Tuple{T}} where R where N where T","page":"States","title":"LinearAlgebra.norm","text":"norm(s::ClusteredState{T,N,R}) where {T,N,R}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.:+-Tuple{FermiCG.TuckerState,FermiCG.TuckerState}","page":"States","title":"Base.:+","text":"+(ts1::FermiCG.TuckerState, ts2::FermiCG.TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.Multimedia.display-Tuple{FermiCG.TuckerState}","page":"States","title":"Base.Multimedia.display","text":"Base.display(s::TuckerState; thresh=1e-3)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.length-Tuple{FermiCG.TuckerState}","page":"States","title":"Base.length","text":"Base.length(s::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add!-Tuple{FermiCG.TuckerState,FermiCG.TuckerState}","page":"States","title":"FermiCG.add!","text":"add!(ts1::FermiCG.TuckerState, ts2::FermiCG.TuckerState)\n\nAdd coeffs in ts2 to ts1\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add_fockconfig!-Tuple{FermiCG.TuckerState,FockConfig}","page":"States","title":"FermiCG.add_fockconfig!","text":"add_fockconfig!(s::ClusteredState, fock::FockConfig)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.dot-Tuple{FermiCG.TuckerState,FermiCG.TuckerState}","page":"States","title":"FermiCG.dot","text":"dot(ts1::FermiCG.TuckerState, ts2::FermiCG.TuckerState)\n\nDot product between in ts2 to ts1\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.expand_each_fock_space!-Tuple{FermiCG.TuckerState,Array{ClusterBasis,1}}","page":"States","title":"FermiCG.expand_each_fock_space!","text":"expand_each_fock_space!(s::TuckerState, bases)\n\nFor each fock space sector defined, add all possible basis states \n\nbases::Vector{ClusterBasis} \n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.eye!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.eye!","text":"eye!(s::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.fold!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.fold!","text":"fold!(ts::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.get_vector-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.get_vector","text":"get_vector(s::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.mult!-Tuple{FermiCG.TuckerState,Any}","page":"States","title":"FermiCG.mult!","text":"mult!(ts::TuckerState, A)\n\nMultiple ts by a matrix A. This is a multiplication over global state index\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.orthogonalize!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.orthogonalize!","text":"orthogonalize!(ts::TuckerState)\n\nSymmetric Orthogonalization of vectors in ts\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.print_fock_occupations-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.print_fock_occupations","text":"print_fock_occupations(s::TuckerState; root=1, thresh=1e-3)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.prune_empty_fock_spaces!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.prune_empty_fock_spaces!","text":"prune_empty_fock_spaces!(s::TuckerState)\n\nremove fock_spaces that don't have any configurations \n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.randomize!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.randomize!","text":"randomize!(ts::TuckerState; scale=1)\n\nAdd some random noise to the vector\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.scale!-Tuple{FermiCG.TuckerState,Any}","page":"States","title":"FermiCG.scale!","text":"scale!(ts::FermiCG.TuckerState, a)\n\nScale ts by a constant a\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.set_vector!-Tuple{FermiCG.TuckerState,Any}","page":"States","title":"FermiCG.set_vector!","text":"set_vector!(s::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.unfold!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.unfold!","text":"unfold!(ts::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.zero!-Tuple{FermiCG.TuckerState}","page":"States","title":"FermiCG.zero!","text":"zero!(s::TuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.Multimedia.display-Tuple{FermiCG.CompressedTuckerState}","page":"States","title":"Base.Multimedia.display","text":"Base.display(s::CompressedTuckerState; thresh=1e-3)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.length-Tuple{FermiCG.CompressedTuckerState}","page":"States","title":"Base.length","text":"Base.length(s::CompressedTuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.add_fockconfig!-Union{Tuple{N}, Tuple{T}, Tuple{FermiCG.CompressedTuckerState{T,N},FockConfig}} where N where T","page":"States","title":"FermiCG.add_fockconfig!","text":"add_fockconfig!(s::CompressedTuckerState, fock::FockConfig)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.compress-Union{Tuple{FermiCG.CompressedTuckerState{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"States","title":"FermiCG.compress","text":"compress(ts::CompressedTuckerState{T,N}; thresh=-1, max_number=nothing, verbose=0) where {T,N}\n\nCompress state via HOSVD\n\nArguments\n\nts::CompressedTuckerState\nthresh = -1: threshold for compression\nmax_number: only keep certain number of vectors per TuckerConfig\nverbose=0: print level\n\nReturns\n\nCompressedTuckerState\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.get_vector-Tuple{FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.get_vector","text":"get_vector(s::CompressedTuckerState)\n\nReturn a vector of the variables. Note that this is the core tensors being returned\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.nonorth_add!-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.nonorth_add!","text":"nonorth_add!(ts1::CompressedTuckerState, ts2::CompressedTuckerState)\n\nAdd coeffs in ts2 to ts1\n\nNote: this does not assume t1 and t2 have the same compression vectors\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.nonorth_dot-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.nonorth_dot","text":"nonorth_dot(ts1::FermiCG.CompressedTuckerState, ts2::FermiCG.CompressedTuckerState; verbose=0)\n\nDot product between 1ts2andts1` where each have their own Tucker factors\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.orth_add!-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.orth_add!","text":"orth_add!(ts1::CompressedTuckerState, ts2::CompressedTuckerState)\n\nAdd coeffs in ts2 to ts1\n\nNote: this assumes t1 and t2 have the same compression vectors\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.orth_dot-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.orth_dot","text":"dot(ts1::FermiCG.CompressedTuckerState, ts2::FermiCG.CompressedTuckerState)\n\nDot product between ts2 and ts1\n\nWarning: this assumes both ts1 and ts2 have the same tucker factors for each TuckerConfig\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.print_fock_occupations-Tuple{FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.print_fock_occupations","text":"print_fock_occupations(s::CompressedTuckerState; thresh=1e-3)\n\nPretty print\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.prune_empty_TuckerConfigs!-Tuple{T} where T<:Union{FermiCG.CompressedTuckerState, FermiCG.TuckerState}","page":"States","title":"FermiCG.prune_empty_TuckerConfigs!","text":"prune_empty_TuckerConfigs!(s::T) where T<:Union{TuckerState, CompressedTuckerState}\n\nremove fock_spaces that don't have any configurations\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.prune_empty_fock_spaces!-Tuple{FermiCG.AbstractState}","page":"States","title":"FermiCG.prune_empty_fock_spaces!","text":"prune_empty_fock_spaces!(s::AbstractState)\n\nremove fock_spaces that don't have any configurations\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.scale!-Union{Tuple{T}, Tuple{FermiCG.CompressedTuckerState,T}} where T<:Number","page":"States","title":"FermiCG.scale!","text":"scale!(ts::FermiCG.CompressedTuckerState, a::T<:Number)\n\nScale ts by a constant\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.set_vector!-Tuple{FermiCG.CompressedTuckerState,Any}","page":"States","title":"FermiCG.set_vector!","text":"set_vector!(s::CompressedTuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.zero!-Tuple{FermiCG.CompressedTuckerState}","page":"States","title":"FermiCG.zero!","text":"zero!(s::CompressedTuckerState)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.:+-Union{Tuple{N}, Tuple{FockConfig{N},FermiCG.TransferConfig{N}}} where N","page":"States","title":"Base.:+","text":"Base.:+(a::FockConfig, b::TransferConfig)\n\nAdd a FockConfig to a TransferConfig to get a new FockConfig\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.:--Union{Tuple{N}, Tuple{FockConfig{N},FockConfig{N}}} where N","page":"States","title":"Base.:-","text":"Base.:-(a::FockConfig, b::FockConfig)\n\nSubtract two FockConfig's, returning a TransferConfig\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.convert-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{Type{FermiCG.TransferConfig{N}},Tuple{Vararg{Tuple{T,T},M}}}} where M where N where T","page":"States","title":"Base.convert","text":"function Base.convert(::Type{TransferConfig{N}}, in::NTuple{M,Tuple{T,T}}) where {T,N,M}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.convert-Union{Tuple{N}, Tuple{Type{FockConfig{N}},Array{T,1} where T}} where N","page":"States","title":"Base.convert","text":"function Base.convert(::Type{FockConfig{N}}, in::Vector) where {N}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.convert-Union{Tuple{N}, Tuple{T}, Tuple{Type{FermiCG.TransferConfig{N}},Array{Tuple{T,T},1}}} where N where T","page":"States","title":"Base.convert","text":"function Base.convert(::Type{TransferConfig{N}}, in::Vector{Tuple{T,T}}) where {T,N}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#Base.convert-Union{Tuple{N}, Tuple{T}, Tuple{Type{FermiCG.TuckerConfig{N}},Array{UnitRange{T},1}}} where N where T","page":"States","title":"Base.convert","text":"function Base.convert(::Type{TuckerConfig{N}}, in::Vector{UnitRange{T}}) where {T,N}\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.dim-Tuple{FermiCG.TuckerConfig}","page":"States","title":"FermiCG.dim","text":"dim(tc::TuckerConfig)\n\nReturn total dimension of space indexed by tc\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.dim-Tuple{FockConfig,Any}","page":"States","title":"FermiCG.dim","text":"dim(fc::FockConfig, no)\n\nReturn total dimension of space indexed by fc on no orbitals\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.is_subset-Tuple{FermiCG.TuckerConfig,FermiCG.TuckerConfig}","page":"States","title":"FermiCG.is_subset","text":"Check if tc1 is a subset of tc2\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.replace-Tuple{FermiCG.TransferConfig,Any,Any}","page":"States","title":"FermiCG.replace","text":"function replace(tc::TransferConfig, idx, fock)\n\n\n\n\n\n","category":"method"},{"location":"library/States/#FermiCG.replace-Union{Tuple{N}, Tuple{ClusterConfig{N},Any,Any}} where N","page":"States","title":"FermiCG.replace","text":"function replace(cc::ClusterConfig{N}, idx, conf) where N\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredStates/","page":"ClusteredStates","title":"ClusteredStates","text":"Pages = [\"ClusteredStates.md\"]","category":"page"},{"location":"library/ClusteredStates/#ClusteredStates","page":"ClusteredStates","title":"ClusteredStates","text":"","category":"section"},{"location":"library/ClusteredStates/","page":"ClusteredStates","title":"ClusteredStates","text":"Modules = [FermiCG]\nPages   = [\"ClusteredStates.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"installation_instructions/#FermiCG","page":"Installation Instructions","title":"FermiCG","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"A Julia package for course-grained electronic structure calculations","category":"page"},{"location":"installation_instructions/#Installation","page":"Installation Instructions","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Download","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"git clone https://github.com/nmayhall-vt/FermiCG.git\ncd FermiCG/","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Create python virtual environment which will hold the PYSCF executable","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"cd src/python\nvirtualenv -p python3 venv\nsource venv/bin/activate\npip install -r requirements.txt\ncd ../../\njulia --project=./\njulia> using Pkg; Pkg.build(\"PyCall\")","category":"page"},{"location":"cmf/#Cluster-Mean-Field-Calculation-(CMF)","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"","category":"section"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"In this example, we cluster a sequence of H<sub>2</sub> molecules and solve them self-consistently","category":"page"},{"location":"cmf/#First-create-a-molecule","page":"Cluster Mean-Field Calculation (CMF)","title":"First create a molecule","text":"","category":"section"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"using FermiCG\n\natoms = []\npush!(atoms,Atom(1,\"H\",[0,0,0]))\npush!(atoms,Atom(2,\"H\",[0,0,1]))\npush!(atoms,Atom(3,\"H\",[0,0,2]))\npush!(atoms,Atom(4,\"H\",[0,0,3]))\npush!(atoms,Atom(5,\"H\",[0,0,4]))\npush!(atoms,Atom(6,\"H\",[0,0,5]))\nbasis = \"sto-3g\"","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now create a PySCF object for creating integrals, and run FCI with 3 alpha and 3 beta electrons","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"mol  = Molecule(0,1,atoms)\nmf   = FermiCG.pyscf_do_scf(mol,basis)\nints = FermiCG.pyscf_build_ints(mf.mol,mf.mo_coeff);\n\nna = 3\nnb = 3\ne_fci, d1_fci, d2_fci = FermiCG.pyscf_fci(ints,na,nb)\nC = mf.mo_coeff\nrdm_mf = C[:,1:2] * C[:,1:2]'","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Localize the orbitals and print to molden file for viewing","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Cl = FermiCG.localize(mf.mo_coeff,\"lowdin\",mf)\nFermiCG.pyscf_write_molden(mol,basis,Cl,filename=\"lowdin.molden\")\nS = FermiCG.get_ovlp(mf)\nU =  C' * S * Cl","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Rotate the integrals to this new localized basis","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"ints = FermiCG.orbital_rotation(ints,U)","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now we need to specify a clustering","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"clusters    = [(1:2),(3:4),(5:6)]\ninit_fspace = [(1,1),(1,1),(1,1)]\n\nclusters = [Cluster(i,collect(clusters[i])) for i = 1:length(clusters)]\ndisplay(clusters)\n\nrdm1 = zeros(size(ints.h1))\nrdm1a = rdm_mf*.5\nrdm1b = rdm_mf*.5\n","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"Now run the orbital optimization and dump the resultinging orbitals ","category":"page"},{"location":"cmf/","page":"Cluster Mean-Field Calculation (CMF)","title":"Cluster Mean-Field Calculation (CMF)","text":"U = FermiCG.cmf_oo(ints, clusters, init_fspace, rdm1, verbose=0, gconv=1e-6)\n\nC_cmf = Cl*U\n\nFermiCG.pyscf_write_molden(mol,basis,C_cmf,filename=\"cmf.molden\")","category":"page"},{"location":"library/BST/#BST","page":"BST","title":"BST","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"The Block-Sparse Tucker (BST) method, approximates FCI as a linear combination of individually compressed (via HOSVD) blocks of the Hilbert space.","category":"page"},{"location":"library/BST/#Background","page":"BST","title":"Background","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Similar to TPSCI, the approach here starts with a CMF wavefunction, and systematically reintroduces the discarded tensor product states to variationally approach FCI. Unlike with TPSCI, however, we don't assume that the final wavefunction is written as  a purely sparse form (where only a few TPS's are needed), but rather we assume that collections of TPS's where certain numbers of clusters are \"excited\" can be efficiently compressed via HOSVD (although the basic idea would extend to other tensor decompositions, like CP or MPS). ","category":"page"},{"location":"library/BST/#Performance-considerations","page":"BST","title":"Performance considerations","text":"","category":"section"},{"location":"library/BST/#Index","page":"BST","title":"Index","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Pages   = [\"BST.md\"]","category":"page"},{"location":"library/BST/#Documentation","page":"BST","title":"Documentation","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Modules = [FermiCG]\nPages   = [\"tucker_inner.jl\",\"tucker_outer.jl\",\"bst.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/BST/#FermiCG.build_dense_H_term-Tuple{FermiCG.ClusteredTerm1B,Any,Any,Any,FermiCG.Tucker,Any,Any,FermiCG.Tucker}","page":"BST","title":"FermiCG.build_dense_H_term","text":"Contract integrals and ClusterOps to form dense 4-body Hamiltonian matrix (tensor) in Tucker basis\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.build_sigma!-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.build_sigma!","text":"build_sigma_parallel!(sigma_vector::CompressedTuckerState, ci_vector::CompressedTuckerState, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.build_sigma_serial!-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.build_sigma_serial!","text":"build_sigma!(sigma_vector::CompressedTuckerState, ci_vector::CompressedTuckerState, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.cache_hamiltonian-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.cache_hamiltonian","text":"build_sigma!(sigma_vector::CompressedTuckerState, ci_vector::CompressedTuckerState, cluster_ops, clustered_ham)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.contract_dense_H_with_state-Union{Tuple{N}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Any,Any,FermiCG.Tucker{T,N},FermiCG.Tucker{T,N}}} where N where T","page":"BST","title":"FermiCG.contract_dense_H_with_state","text":"Contract  Hamiltonian matrix (tensor) in Tucker basis with trial vector (Tucker)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.build_compressed_1st_order_state-Union{Tuple{N}, Tuple{T}, Tuple{FermiCG.CompressedTuckerState{T,N},Any,Any}} where N where T","page":"BST","title":"FermiCG.build_compressed_1st_order_state","text":"build_compressed_1st_order_state(cts::CompressedTuckerState{T,N}, cluster_ops, clustered_ham; thresh=1e-7, max_number=nothing, nbody=2) where {T,N}\n\nApply the Hamiltonian to v expanding into the uncompressed space. This is done only partially, where each term is recompressed after being computed. Lots of overhead probably from compression, but never completely uncompresses.\n\n#Arguments\n\ncts::CompressedTuckerState: input state\ncluster_ops:\nclustered_ham: Hamiltonian\nthresh: Threshold for Tucker decomosition\nmax_number: max number of tucker factors kept\nnbody: allows one to limit (max 4body) terms in the Hamiltonian considered\n\n#Returns\n\nv1::CompressedTuckerState\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.define_foi_space-Union{Tuple{T}, Tuple{T,Any}} where T<:Union{FermiCG.CompressedTuckerState, FermiCG.TuckerState}","page":"BST","title":"FermiCG.define_foi_space","text":"define_foi_space(v::CompressedTuckerState, clustered_ham; nbody=2)\n\nCompute the first-order interacting space as defined by clustered_ham\n\n#Arguments\n\nv::CompressedTuckerState: input state\nclustered_ham: Hamiltonian\nnbody: allows one to limit (max 4body) terms in the Hamiltonian considered\n\n#Returns\n\nfoi::OrderedDict{FockConfig,Vector{TuckerConfig}}\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.get_map-Tuple{FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.get_map","text":"get_map(ci_vector::CompressedTuckerState, cluster_ops, clustered_ham)\n\nGet LinearMap with takes a vector and returns action of H on that vector\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.hylleraas_compressed_mp2-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.hylleraas_compressed_mp2","text":"hylleraas_compressed_mp2(sig_in::CompressedTuckerState, ref::CompressedTuckerState,\n        cluster_ops, clustered_ham;\n        H0 = \"Hcmf\", tol=1e-6, nbody=4, max_iter=40, verbose=1, do_pt = true, thresh=1e-8)\n\nH0: [\"H\", \"Hcmf\"] \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.project_out!-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState}","page":"BST","title":"FermiCG.project_out!","text":"project_out!(v::CompressedTuckerState, w::CompressedTuckerState; thresh=1e-16)\n\nProject w out of v  |v'> = |v> - |w><w|v>\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.solve_for_compressed_space-Tuple{FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.solve_for_compressed_space","text":"solve_for_compressed_space(ref_vector::CompressedTuckerState, cluster_ops, clustered_ham;\n    max_iter    = 20,\n    H0          = \"cmf\",\n    nbody       = 4,\n    thresh_foi  = 1e-6,\n    thresh_var  = 1e-4,\n    tol_ci      = 1e-5,\n    tol_tucker  = 1e-6)\n\nArguments\n\nref_vector: initial state\nnbody: max number of nbody terms in the Hamiltonian used for creating FOIS\nthresh_foi: Compression threshold for the FOIS, or first order wavefunction\nthresh_var: Compression threshold for the variational solution\ntol_ci:     Convergence threshold for the CI (norm of residual)\ntol_tucker: Convergence threshold for Tucker iterations (energy change)\nH0: [\"Hcmf\", \"H\"]\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_cepa_solve-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.tucker_cepa_solve","text":"tucker_cepa_solve!(ref_vector::CompressedTuckerState, cepa_vector::CompressedTuckerState, cluster_ops, clustered_ham; tol=1e-5, cache=true)\n\nArguments\n\nref_vector: Input reference state. \ncepa_vector: CompressedTuckerState which defines the configurational space defining {X}. This \n\nshould be the first-order interacting space (or some compressed version of it).\n\ncluster_ops\nclustered_ham\ntol: haven't yet set this up (NYI)\ncache: Should we cache the compressed H operators? Speeds up drastically, but uses lots of memory\n\nCompute compressed CEPA. Since there can be non-zero overlap with a multireference state, we need to generalize.\n\nHC = SCe\n\n|Haa + Hax| |1 | = |I   + Sax| |1 | E\n|Hxa + Hxx| |Cx|   |Sxa + I  | |Cx|\n\nHaa + Hax*Cx = (1 + Sax*Cx)E\nHxa + HxxCx = SxaE + CxE\n\nThe idea for CEPA is to approximate E in the amplitude equation. CEPA(0): E = Eref\n\n(Hxx-Eref)*Cx = Sxa*Eref - Hxa\n\nAx=b\n\nAfter solving, the Energy can be obtained as:\n\nE = (Eref + Hax*Cx) / (1 + Sax*Cx)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_cepa_solve2-Tuple{FermiCG.CompressedTuckerState,FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.tucker_cepa_solve2","text":"tucker_cepa_solve!(ref_vector::CompressedTuckerState, cepa_vector::CompressedTuckerState, cluster_ops, clustered_ham; tol=1e-5, cache=true)\n\nArguments\n\nref_vector: Input reference state. \ncepa_vector: CompressedTuckerState which defines the configurational space defining {X}. This \n\nshould be the first-order interacting space (or some compressed version of it).\n\ncluster_ops\nclustered_ham\ntol: haven't yet set this up (NYI)\ncache: Should we cache the compressed H operators? Speeds up drastically, but uses lots of memory\n\nCompute compressed CEPA. Since there can be non-zero overlap with a multireference state, we need to generalize.\n\nHC = SCe\n\n|Haa + Hax| |1 | = |I   + Sax| |1 | E |Hxa + Hxx| |Cx|   |Sxa + I  | |Cx|\n\nHaa + HaxCx = (1 + SaxCx)E Hxa + HxxCx = SxaE + CxE\n\nThe idea for CEPA is to approximate E in the amplitude equation. CEPA(0): E = Eref\n\n(Hxx-Eref)Cx = SxaEref - Hxa\n\nAx=b\n\nAfter solving, the Energy can be obtained as: E = (Eref + HaxCx) / (1 + SaxCx)\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_ci_solve-Tuple{FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.tucker_ci_solve","text":"tucker_ci_solve(ci_vector::CompressedTuckerState, cluster_ops, clustered_ham; tol=1e-5)\n\nSolve for ground state in the space spanned by ci_vector's compression vectors\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.block_sparse_tucker-Tuple{FermiCG.CompressedTuckerState,Any,Any}","page":"BST","title":"FermiCG.block_sparse_tucker","text":"block_sparse_tucker(input_vec::CompressedTuckerState, cluster_ops, clustered_ham;\n    max_iter    = 20,\n    max_iter_pt = 200, \n    nbody       = 4,\n    H0          = \"Hcmf\",\n    thresh_var  = 1e-4,\n    thresh_foi  = 1e-6,\n    thresh_pt   = 1e-5,\n    tol_ci      = 1e-5,\n    do_pt       = true,\n    tol_tucker  = 1e-6)\n\nArguments\n\ninput_vec::CompressedTuckerState: initial state\ncluster_ops: local cluster operators\nclustered_ham::ClusteredOperator: hamiltonian\nmax_iter = 20: max number of iterations\nmax_iter_pt = 200: max number of iterations to solve for the 1st order wavefunction\nnbody = 4: include up to nbody terms when forming the FOIS to search\nH0 = \"Hcmf\": zeroth-order hamiltonian for computing 1st order wavefunction [\"Hcmf\", \"H\"]\nnbody: max number of nbody terms in the Hamiltonian used for creating FOIS\nthresh_var: Compression threshold for the variational solution\nthresh_foi: Compression threshold for the FOIS\nthresh_pt: Compression threshold for the first-order wavefunction (if used)\ntol_ci:     Convergence threshold for the CI (norm of residual)\ndo_pt = true: Compute pt1 wavefunction for finding updated compression basis?\ntol_tucker: Convergence threshold for Tucker iterations (energy change)\n\nReturns\n\ne_var::Float64: the final variational energy\nv_var::CompressedTuckerState: the final variational state\n\nSee also: CompressedTuckerState, Tucker\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#HOSVD","page":"BST","title":"HOSVD","text":"","category":"section"},{"location":"library/BST/","page":"BST","title":"BST","text":"Modules = [FermiCG]\nPages   = [\"hosvd.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/BST/#FermiCG.Tucker","page":"BST","title":"FermiCG.Tucker","text":"Simple Tucker (HOSVD) type\n\nData\n\ncore::Array{T, N}\nfactors::NTuple{N, Matrix{T}}\n\nTucker factors are stored as tall matrices\n\n\n\n\n\n","category":"type"},{"location":"library/BST/#FermiCG.add-Union{Tuple{Array{FermiCG.Tucker{T,N},1}}, Tuple{N}, Tuple{T}} where N where T","page":"BST","title":"FermiCG.add","text":"add(tucks::Vector{Tucker{T,N}}; thresh=1e-10, max_number=nothing) where {T,N}\n\nAdd together multiple Tucker instances. Assumed non-orthogonal.\n\nArguments\n\ntucks::Vector{Tucker{T,N}}: Vector of Tucker objects\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.compress-Union{Tuple{FermiCG.Tucker{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"BST","title":"FermiCG.compress","text":"compress(t::Tucker{T,N}; thresh=1e-7, max_number=nothing) where {T,N}\n\nTry to compress further \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.dot-Union{Tuple{N}, Tuple{T}, Tuple{FermiCG.Tucker{T,N},FermiCG.Tucker{T,N}}} where N where T","page":"BST","title":"FermiCG.dot","text":"dot(t1::Tucker{T,N}, t2::Tucker{T,N}) where {T,N}\n\nNote: This doesn't assume t1 and t2 have the same compression vectors \n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.transform_basis-Union{Tuple{N}, Tuple{T}, Tuple{Array{T,N},Dict{Int64,Array{T,2}}}} where N where T","page":"BST","title":"FermiCG.transform_basis","text":"\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.transform_basis-Union{Tuple{N}, Tuple{T}, Tuple{Array{T,N},Tuple{Vararg{Array{T,2},N}}}} where N where T","page":"BST","title":"FermiCG.transform_basis","text":"\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_decompose-Union{Tuple{Array{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"BST","title":"FermiCG.tucker_decompose","text":"Tucker Decomposition of dense tensor:  A ~ X *(1) U1 *(2) U2 ....\n\n\n\n\n\n","category":"method"},{"location":"library/BST/#FermiCG.tucker_recompose-Tuple{Any,Any}","page":"BST","title":"FermiCG.tucker_recompose","text":"tucker_recompose(core, factors)\n\nRecompose Tucker Decomposition \n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#CMF","page":"CMF","title":"CMF","text":"","category":"section"},{"location":"library/CMFs/#Background","page":"CMF","title":"Background","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"The Cluster Mean Field (CMF) approach used in this work was developed by Jimènez-Hoyos and Scuseria. ","category":"page"},{"location":"library/CMFs/#Algorithm","page":"CMF","title":"Algorithm","text":"","category":"section"},{"location":"library/CMFs/#Index","page":"CMF","title":"Index","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"Pages = [\"CMFs.md\"]","category":"page"},{"location":"library/CMFs/#Documentation","page":"CMF","title":"Documentation","text":"","category":"section"},{"location":"library/CMFs/","page":"CMF","title":"CMF","text":"Modules = [FermiCG]\nPages   = [\"CMFs.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/CMFs/#FermiCG.cmf_ci-NTuple{4,Any}","page":"CMF","title":"FermiCG.cmf_ci","text":"cmf_ci(ints, clusters, fspace, dguess; \n        max_iter=10, dconv=1e-6, econv=1e-10, verbose=1)\n\nOptimize the 1RDM for CMF-CI\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci-Tuple{Molecule,Array{T,2} where T,Array{Cluster,1},Array{T,1} where T,Any}","page":"CMF","title":"FermiCG.cmf_ci","text":"cmf_ci(mol::Molecule, C::Matrix, clusters::Vector{Cluster}, fspace::Vector, dguess; \n        max_iter=10, dconv=1e-6, econv=1e-10, verbose=1)\n\nOptimize the 1RDM for CMF-CI, without requiring an InCoreInts object \n\nArguments\n\nmol::Molecule: a FermiCG.Molecule type\nC: MO coefficients for full system (spin restricted)\nclusters::Vector{Cluster}: vector of Cluster objects\nfspace::Vector{Vector{Integer}}: vector of particle number occupations for each cluster specifying the sectors of fock space \ndguess: initial guess for 1particle density matrix (spin summed) \ndconv: Convergence threshold for change in density \neconv: Convergence threshold for change in energy \nverbose: how much to print\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci_iteration-Tuple{InCoreInts,Array{Cluster,1},Any,Any,Any}","page":"CMF","title":"FermiCG.cmf_ci_iteration","text":"cmf_ci_iteration(ints::InCoreInts, clusters::Vector{Cluster}, rdm1a, rdm1b, fspace; verbose=1)\n\nPerform single CMF-CI iteration, returning new energy, and density\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_ci_iteration-Tuple{Molecule,Any,Any,Any,Any,Any}","page":"CMF","title":"FermiCG.cmf_ci_iteration","text":"cmf_ci_iteration(mol::Molecule, C, rdm1a, rdm1b, clusters, fspace; \n                 verbose=1)\n\nPerform single CMF-CI iteration, returning new energy, and density. This method forms the eri's on the fly to avoid global N^4 storage\n\nArguments\n\nmol::Molecule: a FermiCG.Molecule type\nC: MO coefficients for full system (spin restricted)\nrdm1a: 1particle density matrix (alpha) \nrdm1b: 1particle density matrix (beta) \nclusters::Vector{Cluster}: vector of Cluster objects\nfspace::Vector{Vector{Int}}: vector of particle number occupations for each cluster specifying the sectors of fock space \nverbose: how much to print\n\nSee also: cmf_ci_iteration\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_oo-Tuple{InCoreInts,Array{Cluster,1},Any,Any}","page":"CMF","title":"FermiCG.cmf_oo","text":"cmf_oo(ints::InCoreInts, clusters::Vector{Cluster}, fspace, dguess; \n        max_iter_oo=100, max_iter_ci=100, gconv=1e-6, verbose=0, method=\"bfgs\")\n\nDo CMF with orbital optimization\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.cmf_oo-Tuple{Molecule,Array{T,2} where T,Array{Cluster,1},Any,Any}","page":"CMF","title":"FermiCG.cmf_oo","text":"cmf_oo(mol::Molecule, Cguess::Matrix, clusters::Vector{Cluster}, fspace, dguess; \n        max_iter_oo=100, max_iter_ci=100, gconv=1e-6, verbose=0, method=\"bfgs\")\n\nDo CMF with orbital optimization with on the fly integrals\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.compute_cmf_energy-NTuple{4,Any}","page":"CMF","title":"FermiCG.compute_cmf_energy","text":"compute_cmf_energy(ints, rdm1s, rdm2s, clusters)\n\nCompute the energy of a cluster-wise product state (CMF), specified by a list of 1 and 2 particle rdms local to each cluster. This method uses the full system integrals.\n\nints::InCoreInts: integrals for full system\nrdm1s: dictionary (ci.idx => Array) of 1rdms from each cluster (spin summed)\nrdm2s: dictionary (ci.idx => Array) of 2rdms from each cluster (spin summed)\nclusters::Vector{Cluster}: vector of cluster objects\n\nreturn the total CMF energy\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.compute_cmf_energy-Tuple{Molecule,Array{T,2} where T,Any,Any,Any}","page":"CMF","title":"FermiCG.compute_cmf_energy","text":"compute_cmf_energy(mol::Molecule, C::Matrix, rdm1s, rdm2s, clusters)\n\nCompute the energy of a cluster-wise product state (CMF), specified by a list of 1 and 2 particle rdms local to each cluster\n\n#Arguments\n\nmol::Molecule\nC::Matrix: MO coefficients\nrdm1s: dictionary (ci.idx => Array) of 1rdms from each cluster (spin summed)\nrdm2s: dictionary (ci.idx => Array) of 2rdms from each cluster (spin summed)\nclusters::Vector{Cluster}: vector of cluster objects\n\nreturn the total CMF energy\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.form_casci_eff_ints-Tuple{InCoreInts,Any,Any,Any}","page":"CMF","title":"FermiCG.form_casci_eff_ints","text":"form_casci_eff_ints(ints::InCoreInts, orb_list, rdm1a, rdm1b)\n\nObtain a subset of integrals which act on the orbitals in Cluster, embedding the 1rdm from the rest of the system\n\nReturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/CMFs/#FermiCG.form_casci_ints-Tuple{InCoreInts,Cluster,Any,Any}","page":"CMF","title":"FermiCG.form_casci_ints","text":"form_casci_ints(ints::InCoreInts, ci::Cluster, rdm1a, rdm1b)\n\nObtain a subset of integrals which act on the orbitals in Cluster, embedding the 1rdm from the rest of the system\n\nReturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredTerms/","page":"ClusteredTerms","title":"ClusteredTerms","text":"Pages = [\"ClusteredTerms.md\"]","category":"page"},{"location":"library/ClusteredTerms/#ClusteredTerms","page":"ClusteredTerms","title":"ClusteredTerms","text":"","category":"section"},{"location":"library/ClusteredTerms/","page":"ClusteredTerms","title":"ClusteredTerms","text":"Modules = [FermiCG]\nPages   = [\"ClusteredTerms.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/ClusteredTerms/#FermiCG.ClusteredOperator","page":"ClusteredTerms","title":"FermiCG.ClusteredOperator","text":"trans::Dict{TransferConfig,Vector{ClusteredTerm}}\n\n\n\n\n\n","category":"type"},{"location":"library/ClusteredTerms/#FermiCG.ClusteredTerm","page":"ClusteredTerms","title":"FermiCG.ClusteredTerm","text":"ops::Tuple{String}\ndelta::TransferConfig{1}\nparity::Tuple{Int}\nclusters::Tuple{Cluster}\nints::Array{Float64}\ncache::Dict\n\ninput:\n\ndelta = list of change of Na,Nb,state\n\n\t\te.g., [(-1,-1),(1,1),(0,0)] means alpha and beta transition\n\t\tfrom cluster 1 to 2, cluster 3 is fock diagonal\n\nops   = list of operators\n\n\t\te.g., [\"ab\",\"AB\",\"\"]\n\nints  = tensor containing the integrals for this block\n\n\t\te.g., ndarray([p,q,r,s]) where p,q are in 1 and r,s are in 2\n\ndata contained in object\n\n\tactive: list of clusters which have non-identity operators\n\t\tthis includes fock-diagonal couplings,\n\t\te.g., [\"Aa\",\"\",\"Bb\"] would have active = [0,2]\n\nparity: does each operator have even or odd number of second quantized operators \n\n\n\n\n\n","category":"type"},{"location":"library/ClusteredTerms/#FermiCG.extract_1body_operator-Tuple{FermiCG.ClusteredOperator}","page":"ClusteredTerms","title":"FermiCG.extract_1body_operator","text":"extract_1body_operator(clustered_ham::ClusteredOperator; op_string=\"H\")\n\nExtract a 1-body operator for use in perturbation theory\n\nop_string: either H or Hcmf\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredTerms/#FermiCG.extract_ClusteredTerms-Tuple{InCoreInts,Any}","page":"ClusteredTerms","title":"FermiCG.extract_ClusteredTerms","text":"extract_terms(ints::InCoreInts, clusters)\n\nExtract all ClusteredTerm types from a given 1e integral tensor  and a list of clusters returns terms::Dict{TransferConfig,Vector{ClusteredTerm}}\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredTerms/#FermiCG.extract_S2-Tuple{Any}","page":"ClusteredTerms","title":"FermiCG.extract_S2","text":"extract_S2(clusters)\n\nForm a clustered operator type for the S^2 operator\n\n\n\n\n\n","category":"method"},{"location":"library/ClusteredTerms/#FermiCG.unique!-Tuple{FermiCG.ClusteredOperator}","page":"ClusteredTerms","title":"FermiCG.unique!","text":"unique!(clustered_ham::ClusteredOperator)\n\ncombine terms to keep only unique operators\n\n\n\n\n\n","category":"method"},{"location":"library/outline/#Library-Outline","page":"-","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"-","title":"-","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Pages = [\"Internals.md\"]","category":"page"},{"location":"library/internals/#Clusters","page":"Internals","title":"Clusters","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Clusters are simply collections of orbitals.","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Clusters.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/internals/#Hamiltonians","page":"Internals","title":"Hamiltonians","text":"","category":"section"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"These are types/methods to handle the fermionic Hamiltonian","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Hamiltonians.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/FermiCG/","page":"FermiCG","title":"FermiCG","text":"Pages = [\"FermiCG.md\"]","category":"page"},{"location":"library/FermiCG/#FermiCG","page":"FermiCG","title":"FermiCG","text":"","category":"section"},{"location":"library/FermiCG/","page":"FermiCG","title":"FermiCG","text":"Modules = [FermiCG]\nPages   = [\"FermiCG.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/PyscfFunctions/","page":"PyscfFunctions","title":"PyscfFunctions","text":"Pages = [\"PyscfFunctions.md\"]","category":"page"},{"location":"library/PyscfFunctions/#PySCF-Functions","page":"PyscfFunctions","title":"PySCF Functions","text":"","category":"section"},{"location":"library/PyscfFunctions/","page":"PyscfFunctions","title":"PyscfFunctions","text":"Modules = [FermiCG]\nPages   = [\"PyscfFunctions.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/PyscfFunctions/#FermiCG.get_ovlp-Tuple{Any}","page":"PyscfFunctions","title":"FermiCG.get_ovlp","text":"get_ovlp(mf)\n\nGet overlap matrix from pyscf using mean-field object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.localize-Tuple{Array{Float64,2},String,Any}","page":"PyscfFunctions","title":"FermiCG.localize","text":"localize(C::Array{Float64,2},method::String, mf)\n\nLocalize the orbitals using method = method\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.make_pyscf_mole-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.make_pyscf_mole","text":"make_pyscf_mole(molecule::Molecule)\n\nCreate a pyscf.gto.Mole() object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_1e-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_1e","text":"pyscf_build_1e(mol::Molecule)\n\nbuild 1 electron integrals in AO basis \n\nArguments\n\nmol::Molecule \n\nreturns a 2D matrix \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_eri-Tuple{Molecule,Array{T,2} where T,Array{T,2} where T,Array{T,2} where T,Array{T,2} where T}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_eri","text":"pyscf_build_eri(mol::Molecule, c1::Matrix, c2::Matrix, c3::Matrix, c4::Matrix)\n\nbuild 2 electron integrals between different orbital spaces, (c1c2|c3c4) \n\nArguments\n\nmol::Molecule \nc1: active space orbital MO coeffs for index 1\nc2: active space orbital MO coeffs for index 2\nc3: active space orbital MO coeffs for index 3\nc4: active space orbital MO coeffs for index 4\n\nreturns a 4D tensor \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_build_ints-Tuple{Molecule,Any,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_build_ints","text":"pyscf_build_ints(mol, c_act, d1_embed)\n\nbuild 1 and 2 electron integrals using a pyscf SCF object\n\nArguments\n\nmol: PySCF Molecule object\nc_act: active space orbital MO coeffs\nd1_embed: 1rdm density matrix for the frozen part in the AO basis (e.g, doccs or frozen clusters)\n\nreturns an InCoreInts type\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_do_scf-Tuple{Molecule}","page":"PyscfFunctions","title":"FermiCG.pyscf_do_scf","text":"pyscf_do_scf(molecule::Molecule, conv_tol=1e-10)\n\nUse PySCF to compute Hartree-Fock for a given molecule and basis set and return a PYSCF mean field object\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_fci-Tuple{Any,Any,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_fci","text":"pyscf_fci(ham, na, nb; max_cycle=20, conv_tol=1e-8, nroots=1, verbose=1)\n\nUse PySCF to compute Full CI\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_get_jk-Tuple{Molecule,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_get_jk","text":"pyscf_get_jk(mol, density)\n\nBuild exchange matrix in AO basis\n\nArguments\n\nmol: PySCF Molecule object\ndensity: 1rdm density matrix for \n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_write_molden-Tuple{Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_write_molden","text":"pyscf_write_molden(mf; filename=\"orbitals.molden\")\n\nArguments\n\nmf: PySCF mean field object\nfilename: Filename to write to\n\nWrite MO coeffs C to a molden file for visualizing\n\n\n\n\n\n","category":"method"},{"location":"library/PyscfFunctions/#FermiCG.pyscf_write_molden-Tuple{Molecule,Any}","page":"PyscfFunctions","title":"FermiCG.pyscf_write_molden","text":"pyscf_write_molden(molecule::Molecule, C; filename=\"orbitals.molden\")\n\nArguments\n\nmolecule::Molecule: Molecule object\nC: MO Coefficients\nfilename: Filename to write to\n\nWrite MO coeffs C to a molden file for visualizing\n\n\n\n\n\n","category":"method"},{"location":"library/function_index/#main-index","page":"-","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"-","title":"-","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"fci/#Simple-(and-slow)-FCI-Calculation-(FCI)","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"","category":"section"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"In this example, we cluster a sequence of H<sub>2</sub> molecules","category":"page"},{"location":"fci/#First-create-a-molecule","page":"Simple (and slow) FCI Calculation (FCI)","title":"First create a molecule","text":"","category":"section"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"using FermiCG\n\natoms = []\npush!(atoms,Atom(1,\"H\",[0,0,0]))\npush!(atoms,Atom(2,\"H\",[0,0,1]))\npush!(atoms,Atom(3,\"H\",[0,0,2]))\npush!(atoms,Atom(4,\"H\",[0,0,3]))\npush!(atoms,Atom(5,\"H\",[0,0,4]))\npush!(atoms,Atom(6,\"H\",[0,0,5]))\nbasis = \"sto-3g\"","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Now create a PySCF object for creating integrals, and run FCI with 3 alpha and 3 beta electrons","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"mol  = Molecule(0,1,atoms)\nmf   = FermiCG.pyscf_do_scf(mol,basis)\nints = FermiCG.pyscf_build_ints(mf.mol,mf.mo_coeff);\n\nna = 3\nnb = 3\ne_fci, d1_fci, d2_fci = FermiCG.pyscf_fci(ints,na,nb)\nC = mf.mo_coeff\nrdm_mf = C[:,1:2] * C[:,1:2]'","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Create an FCIProblem object containing problem data","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"norbs = size(ints.h1)[1]\n\nproblem = StringCI.FCIProblem(norbs, 4, 4)","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"Now run the CI code. This seems to be about 10x slower than pyscf at the moment, and only uses lanczos instead of a preconditioned solver ","category":"page"},{"location":"fci/","page":"Simple (and slow) FCI Calculation (FCI)","title":"Simple (and slow) FCI Calculation (FCI)","text":"StringCI.run_fci(ints, problem)","category":"page"},{"location":"library/Internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Pages = [\"Internals.md\"]","category":"page"},{"location":"library/Internals/#Clusters","page":"Internals","title":"Clusters","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Clusters are simply collections of orbitals.","category":"page"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Clusters.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/Internals/#FermiCG.Cluster","page":"Internals","title":"FermiCG.Cluster","text":"idx::Int\norb_list::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#FermiCG.ClusterBasis","page":"Internals","title":"FermiCG.ClusterBasis","text":"cluster::Cluster                            # Cluster to which basis belongs\nbasis::Dict{Tuple,Matrix{Float64}}          # Basis vectors (nα, nβ)=>[I,s]\n\nThese basis coefficients map local slater determinants to local vectors (nα, nβ):  V[αstring*βstring, cluster_state]\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#FermiCG.ClusterSubspace","page":"Internals","title":"FermiCG.ClusterSubspace","text":"Defines a single cluster's subspace for Tucker. Each focksector is allowed to have a distinct cluster state range  for the subspace.\n\ncluster::Cluster\ndata::OrderedDict{Tuple{UInt8,UInt8}, UnitRange{Int}}\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#Base.Multimedia.display-Tuple{Cluster}","page":"Internals","title":"Base.Multimedia.display","text":"display(c::Cluster)\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#Base.length-Tuple{Cluster}","page":"Internals","title":"Base.length","text":"length(c::Cluster)\n\nReturn number of orbitals in Cluster\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.compute_cluster_eigenbasis-Tuple{InCoreInts,Array{Cluster,1}}","page":"Internals","title":"FermiCG.compute_cluster_eigenbasis","text":"compute_cluster_eigenbasis(ints::InCoreInts, clusters::Vector{Cluster}; \n    init_fspace=nothing, delta_elec=nothing, verbose=0, max_roots=10, \n    rdm1a=nothing, rdm1b=nothing)\n\nReturn a Vector of ClusterBasis for each Cluster \n\nints::InCoreInts: In-core integrals\nclusters::Vector{Cluster}: Clusters \nverbose::Int: Print level\ninit_fspace: list of pairs of (nα,nβ) for each cluster for defining reference space                for selecting out only certain fock sectors\ndelta_elec: number of electrons different from reference (init_fspace)\nmax_roots::Int: Maximum number of vectors for each focksector basis\nrdm1a: background density matrix for embedding local hamiltonian (alpha)\nrdm1b: background density matrix for embedding local hamiltonian (beta)\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.compute_cluster_est_basis-Tuple{InCoreInts,Array{Cluster,1},Any,Any}","page":"Internals","title":"FermiCG.compute_cluster_est_basis","text":"compute_cluster_est_basis(ints::InCoreInts, clusters::Vector{Cluster}; \n    init_fspace=nothing, delta_elec=nothing, verbose=0, max_roots=10, \n    rdm1a=nothing, rdm1b=nothing)\n\nReturn a Vector of ClusterBasis for each Cluster  using the Embedded Schmidt Truncation\n\nints::InCoreInts: In-core integrals\nclusters::Vector{Cluster}: Clusters \nDa: background density matrix for embedding local hamiltonian (alpha)\nDb: background density matrix for embedding local hamiltonian (beta)\ninit_fspace: list of pairs of (nα,nβ) for each cluster for defining reference space                for selecting out only certain fock sectors\nthresh_schmidt: the threshold for the EST \nthresh_orb: threshold for the orbital\nthresh_ci: threshold for the ci problem\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.compute_cluster_ops-Tuple{Array{ClusterBasis,1},Any}","page":"Internals","title":"FermiCG.compute_cluster_ops","text":"compute_cluster_ops(cluster_bases::Vector{ClusterBasis})\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.dim_tot-Tuple{Cluster,Any,Any}","page":"Internals","title":"FermiCG.dim_tot","text":"dim_tot(c::Cluster, na, nb)\n\nReturn dimension of hilbert space spanned by number of orbitals in Cluster with na and nb number of alpha/beta electrons.\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.dim_tot-Tuple{Cluster}","page":"Internals","title":"FermiCG.dim_tot","text":"dim_tot(c::Cluster)\n\nReturn dimension of hilbert space spanned by number of orbitals in Cluster.  This is all sectors\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.form_schmidt_basis-Tuple{InCoreInts,Cluster,Any,Any}","page":"Internals","title":"FermiCG.form_schmidt_basis","text":"form_schmidt_basis\n\nthreshorb      :   threshold for determining how many bath orbitals to include threshschmidt  :   threshold for determining how many singular vectors to include for cluster basis\n\nReturns new basis for the cluster\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.get_ortho_compliment-Tuple{FermiCG.ClusterSubspace,ClusterBasis}","page":"Internals","title":"FermiCG.get_ortho_compliment","text":"get_ortho_compliment(tss::ClusterSubspace, cb::ClusterBasis)\n\nFor a given ClusterSubspace, tss, return the subspace remaining\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.possible_focksectors-Tuple{Cluster}","page":"Internals","title":"FermiCG.possible_focksectors","text":"possible_focksectors(c::Cluster, delta_elec=nothing)\n\nGet list of possible fock spaces accessible to the cluster\n\ndelta_elec::Vector{Int}: (nα, nβ, Δ) restricts fock spaces to: (nα,nβ) ± Δ electron transitions\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.rotate!-Union{Tuple{T}, Tuple{ClusterBasis,Dict{Tuple,Array{T,2}}}} where T","page":"Internals","title":"FermiCG.rotate!","text":"rotate!(cb::ClusterBasis, U::Dict{Tuple,Matrix{T}}) where {T}\n\nRotate cb by unitary matrices in U\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.rotate!-Union{Tuple{T}, Tuple{FermiCG.ClusterOps,Dict{Tuple,Array{T,2}}}} where T","page":"Internals","title":"FermiCG.rotate!","text":"rotate!(ops::ClusterOps, U::Dict{Tuple,Matrix{T}}) where {T}\n\nRotate ops by unitary matrices in U\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_A-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_A","text":"tdm_A(cb::ClusterBasis; verbose=0)\n\nCompute <s|p'|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_AA-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_AA","text":"tdm_AA(cb::ClusterBasis; verbose=0)\n\nCompute <s|p'q'|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_AAa-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_AAa","text":"tdm_AAa(cb::ClusterBasis, spin_case; verbose=0)\n\nCompute <s|p'q'r|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nspin_case: alpha or beta\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_AB-Tuple{ClusterBasis}","page":"Internals","title":"FermiCG.tdm_AB","text":"tdm_AB(cb::ClusterBasis; verbose=0)\n\nCompute <s|p'q'|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space, where p' is alpha and q' is beta.\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_ABa-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_ABa","text":"tdm_ABa(cb::ClusterBasis, spin_case; verbose=0)\n\nCompute <s|p'q'r|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nspin_case: alpha or beta\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_Aa-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_Aa","text":"tdm_Aa(cb::ClusterBasis, spin_case; verbose=0)\n\nCompute <s|p'q|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nspin_case: alpha or beta\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_Ab-Tuple{ClusterBasis}","page":"Internals","title":"FermiCG.tdm_Ab","text":"tdm_Ab(cb::ClusterBasis; verbose=0)\n\nCompute <s|p'q|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space, where p' is alpha and q is beta.\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_H-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_H","text":"tdm_H(cb::ClusterBasis; verbose=0)\n\nCompute local Hamiltonian <s|H|t> between all cluster states, s and t  from accessible sectors of a cluster's fock space.\n\nReturns Dict[((na,nb),(na,nb))] => Array\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.tdm_S2-Tuple{ClusterBasis,Any}","page":"Internals","title":"FermiCG.tdm_S2","text":"\n\n\n\n","category":"method"},{"location":"library/Internals/#Hamiltonians","page":"Internals","title":"Hamiltonians","text":"","category":"section"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"These are types/methods to handle the fermionic Hamiltonian","category":"page"},{"location":"library/Internals/","page":"Internals","title":"Internals","text":"Modules = [FermiCG]\nPages   = [\"Hamiltonians.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/Internals/#FermiCG.Atom","page":"Internals","title":"FermiCG.Atom","text":"id::Integer             #index of atom in the molecule\nsymbol::String          #Atomic ID (E.g. H, He, ...)\nxyz::Array{Float64,1}   #list of XYZ coordinates\n\nSimply an Atom\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#FermiCG.InCoreInts","page":"Internals","title":"FermiCG.InCoreInts","text":"h0::Real                # constant energy shift\nh1::Array{Float64,2}    # one electron integrals\nh2::Array{Float64,4}    # two electron integrals (chemist's notation)\n\nType to hold a second quantized Hamiltonian coefficients in memory\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#FermiCG.Molecule","page":"Internals","title":"FermiCG.Molecule","text":"charge::Integer         #overall charge on molecule\nmultiplicity::Integer   #2S+1\natoms::Vector{Atom}     #Vector of `Atoms`\nbasis::String           #Basis set\n\nMolecule essentially as a Vector of atoms, number of electrons and basis set\n\n\n\n\n\n","category":"type"},{"location":"library/Internals/#FermiCG.compute_energy-NTuple{5,Any}","page":"Internals","title":"FermiCG.compute_energy","text":"compute_energy(h0, h1, h2, rdm1, rdm2)\n\nGiven an energy shift h0, 1e integrals h1, and 2e ints h2 along with a 1rdm and 2rdm on the same space, return the energy\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.compute_energy-Tuple{InCoreInts,Any,Any}","page":"Internals","title":"FermiCG.compute_energy","text":"compute_energy(ints::InCoreInts, rdm1, rdm2)\n\nReturn energy defined by rdm1 and rdm2\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.orbital_rotation!-Tuple{InCoreInts,Any}","page":"Internals","title":"FermiCG.orbital_rotation!","text":"orbital_rotation!(ints::InCoreInts, U)\n\nTransform electronic integrals, by U i.e.,\n\nh_pq = U_rph_rsU_sq\n\n(pqrs) = (tuvw)U_tpU_uqU_vrU_ws\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.orbital_rotation-Tuple{InCoreInts,Any}","page":"Internals","title":"FermiCG.orbital_rotation","text":"orbital_rotation(ints::InCoreInts, U)\n\nTransform electronic integrals, by U i.e.,\n\nh_pq = U_rph_rsU_sq\n\n(pqrs) = (tuvw)U_tpU_uqU_vrU_ws\n\n\n\n\n\n","category":"method"},{"location":"library/Internals/#FermiCG.subset","page":"Internals","title":"FermiCG.subset","text":"subset(ints::InCoreInts, list; rmd1a=nothing, rdm1b=nothing)\n\nExtract a subset of integrals acting on orbitals in list, returned as InCoreInts type\n\nints::InCoreInts: Integrals for full system \nlist: list of orbital indices in subset\nrdm1a: 1RDM for embedding α density to make CASCI hamiltonian\nrdm1b: 1RDM for embedding β density to make CASCI hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"library/TPSCI/#TPSCI","page":"TPSCI","title":"TPSCI","text":"","category":"section"},{"location":"library/TPSCI/#Background","page":"TPSCI","title":"Background","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Tensor Product Selected CI (TPSCI) approximates FCI on large active spaces using a sparse basis of tensor products of many-body cluster states. The main idea is fold much of the electron correlation up into the basis vectors themselves, by diagonalizing local Hamiltonians (Hamiltonians acting on disjoint sets of orbitals, \"clusters\"),  and using the tensor product space of these cluster states as our basis.  For entangled clusters, the convergence of the global energy with the number of local cluster states is slow, making direct truncation of the cluster basis ineffective.  However, instead of seeking a simple trunctation based on local information,  we seek a sparse representation, such that only a small number of global states are needed to obtain an accurate approximation of the ground state. ","category":"page"},{"location":"library/TPSCI/#Algorithm","page":"TPSCI","title":"Algorithm","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"The algorithm consists of the following steps:","category":"page"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"CMF: Optimize both orbitals and cluster ground states to obtain the variationally best single tensor product state wavefunction.\nCompute basis: Compute up to M excited states in each Fock sector desired (defaults to all) for each cluster.   These are excited states of the CMF Hamiltonian, which is an effective 1-cluster Hamiltonian containing the 1RDM contributions from all other clusters.\nForm operators: Compute matrix representations of all the 1, 2, and 3 creation/annihilation operator strings in the CMF cluster basis. E.g.:\nGamma_p^dagger qbarr^IJ = leftIright hatp^dagger hatqhatbarrleft Jright\nwhere I and J are cluster states on the same cluster, with well defined particle number and spin-projection. \nInitialize iterations: Set iteration counter to zero (n=0).  Initialize TPSCI state with CMF wavefunction, in the current mathcalP-space basis lbrace leftP_i^0rightrbrace, with the orthogonal complement defining the mathcalQ-space, lbrace leftQ_i^0rightrbrace.\nIterate Selected CI: \nDiagonalize hatH in the current mathcalP-space, lbrace leftP_i^nrightrbrace\nhatP^nhatHleftpsi^(0)_nright = E_nleftpsi^(0)_nright\nForm PT1 wavefunction by applying the Hamiltonian to the current variational state \nleftpsi^(1)_nright = hatRleftpsi^(0)_nright = sum_i c_i^(1)leftQ_i^nright\nwhere, hatR is the relevant resolvant. \nSelect from  leftpsi^(1)_nright the coefficients with magnitude larger than thresh_cipsi and add to mathcalP space:\nlbraceleftQ^n_irightrbrace xrightarrowc_i^(1)  epsilonlbraceleftP^n+1_jrightrbrace ","category":"page"},{"location":"library/TPSCI/#Tips-on-clustering","page":"TPSCI","title":"Tips on clustering","text":"","category":"section"},{"location":"library/TPSCI/#Performance-considerations","page":"TPSCI","title":"Performance considerations","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Robust integral screening\nthresh_asci \nHOSVD boot-strapping","category":"page"},{"location":"library/TPSCI/#Index","page":"TPSCI","title":"Index","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Pages = [\"TPSCI.md\"]","category":"page"},{"location":"library/TPSCI/#Documentation","page":"TPSCI","title":"Documentation","text":"","category":"section"},{"location":"library/TPSCI/","page":"TPSCI","title":"TPSCI","text":"Modules = [FermiCG]\nPages   = [\"tpsci_inner.jl\",\"tpsci_outer.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm1B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra, bra, fock_ket, ket)\n\nContraction for local (1body) terms. No contraction is needed, just a lookup from the correct operator\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm2B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra, bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm3B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra, bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matrix_element-Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig,ClusterConfig,FockConfig,ClusterConfig}","page":"TPSCI","title":"FermiCG.contract_matrix_element","text":"contract_matrix_element(   term::ClusteredTerm4B, \n                                cluster_ops::Vector{ClusterOps},\n                                fock_bra, bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm1B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(    term::ClusteredTerm2B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm2B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(    term::ClusteredTerm2B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(    term::ClusteredTerm4B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\nThis version should only use M^2N^2 storage, and n^5 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec","text":"contract_matvec(    term::ClusteredTerm4B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\nThis version should only use M^2N^2 storage, and n^5 scaling n={MN}\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_M3-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm3B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_M3","text":"contract_matvec(    term::ClusteredTerm3B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.contract_matvec_M4-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{FermiCG.ClusteredTerm4B,Array{FermiCG.ClusterOps,1},FockConfig{N},FockConfig{N},ClusterConfig{N},StaticArrays.MArray{Tuple{R},T,1,R}}} where N where R where T","page":"TPSCI","title":"FermiCG.contract_matvec_M4","text":"contract_matvec(    term::ClusteredTerm4B, \n                    cluster_ops::Vector{ClusterOps},\n                    fock_bra, fock_ket, ket)\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"Return upper bound on the size of matrix elements resulting from matrix multiply \n\nV[I,J] =  g1[i,I] * g2[i,J] * c \n\nmax(|V|) <= sum_i max|g1[i,:]| * max|g2[i,:]| * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,2},Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"Return upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J] = v[i,j] * g1[i,I] * g2[j,J] \n\nmax(|V|) <= sumij |v[ij]| * |g1[i,:]|8 * |g2[j,:]|_8 * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,3},Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"Return upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K] = v[i,j,k] * g1[i,I] * g2[j,J] * g3[k,K] \n\nmax(|V|) <= sumijk |v[ijk]| * |g1[i,:]|8 * |g2[j,:]|8 * |g3[k,:]|8 * |c|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound-Tuple{Array{Float64,4},Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound","text":"Return upper bound on the size of tensor elements resulting from the following contraction\n\nV[I,J,K,L] = v[i,j,k,l] * g1[i,I] * g2[j,J] * g3[k,K] * g4[l,L]\n\nmax(|V|) <= sumijkl |v[ijkl]| * |g1[i,:]|8 * |g2[j,:]|8 * |g3[k,:]|8 * |g4[l,:]|_8\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2-Tuple{Array{Float64,3},Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound2","text":"max(HIJ(K)|K <= sumr (sumpq vpqrs max(g1[p,:]) * max(g2[q,:]) * |c| ) * |g3(r,K)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.upper_bound2-Tuple{Array{Float64,4},Any,Any,Any,Any,Any}","page":"TPSCI","title":"FermiCG.upper_bound2","text":"max(HIJK(L)|L <= sums (sumpqr vpqrs max(g1[p,:]) * max(g2[q,:]) * max(g3[r,:]) * |c| ) * |g4(s,L)|\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_brdm-Tuple{ClusteredState,Any,Any}","page":"TPSCI","title":"FermiCG.build_brdm","text":"build_brdm(ci_vector::ClusteredState, ci, dims)\n\nBuild block reduced density matrix for Cluster,  ci\n\nci_vector::ClusteredState = input state\nci = Cluster type for whihch we want the BRDM\ndims = list of dimensions for each fock sector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_full_H-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}","page":"TPSCI","title":"FermiCG.build_full_H","text":"build_full_H(ci_vector::ClusteredState, cluster_ops, clustered_ham::ClusteredOperator)\n\nBuild full TPSCI Hamiltonian matrix in space spanned by ci_vector. This works in serial for the full matrix\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.build_full_H_parallel-Tuple{ClusteredState,Any,FermiCG.ClusteredOperator}","page":"TPSCI","title":"FermiCG.build_full_H_parallel","text":"build_full_H(ci_vector::ClusteredState, cluster_ops, clustered_ham::ClusteredOperator)\n\nBuild full TPSCI Hamiltonian matrix in space spanned by ci_vector. This works in serial for the full matrix\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_diagonal-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_diagonal","text":"compute_diagonal(vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham) where {T,N,R}\n\nForm the diagonal of the hamiltonan, clustered_ham, in the basis defined by vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_expectation_value-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_expectation_value","text":"\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.compute_pt2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.compute_pt2","text":"\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.expand_each_fock_space!-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Array{ClusterBasis,1}}} where R where N where T","page":"TPSCI","title":"FermiCG.expand_each_fock_space!","text":"expand_each_fock_space!(s::ClusteredState, bases)\n\nFor each fock space sector defined, add all possible basis states\n\nbasis::Vector{ClusterBasis} \n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.expand_to_full_space!-Tuple{FermiCG.AbstractState,Array{ClusterBasis,1},Any,Any}","page":"TPSCI","title":"FermiCG.expand_to_full_space!","text":"expand_to_full_space(s::ClusteredState, bases)\n\nDefine all possible fock space sectors and add all possible basis states\n\nbasis::Vector{ClusterBasis} \nna: Number of alpha electrons total\nnb: Number of alpha electrons total\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.hosvd-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any}} where R where N where T","page":"TPSCI","title":"FermiCG.hosvd","text":"hosvd(ci_vector::ClusteredState, cluster_ops; hshift=1e-8, truncate=-1)\n\nPeform HOSVD aka Tucker Decomposition of ClusteredState\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.open_matvec-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.open_matvec","text":"open_matvec(ci_vector::ClusteredState, cluster_ops, clustered_ham; thresh=1e-9, nbody=4)\n\nCompute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.open_matvec_parallel-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.open_matvec_parallel","text":"open_matvec_parallel(ci_vector::ClusteredState, cluster_ops, clustered_ham; thresh=1e-9, nbody=4)\n\nCompute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.\n\nThis parallellizes over FockConfigs in the output state, so it's not the most fine-grained, but it avoids data races in  filling the final vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.open_matvec_parallel2-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.open_matvec_parallel2","text":"\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.open_matvec_thread-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,Any}} where R where N where T","page":"TPSCI","title":"FermiCG.open_matvec_thread","text":"open_matvec_thread(ci_vector::ClusteredState, cluster_ops, clustered_ham; thresh=1e-9, nbody=4)\n\nCompute the action of the Hamiltonian on a tpsci state vector. Open here, means that we access the full FOIS  (restricted only by thresh), instead of the action of H on v within a subspace of configurations.  This is essentially used for computing a PT correction outside of the subspace, or used for searching in TPSCI.\n\nThis parallellizes over FockConfigs in the output state, so it's not the most fine-grained, but it avoids data races in  filling the final vector\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.project_out!-Tuple{ClusteredState,ClusteredState}","page":"TPSCI","title":"FermiCG.project_out!","text":"project_out!(v::ClusteredState, w::ClusteredState)\n\nProject w out of v  |v'> = |v> - |w><w|v>\n\n\n\n\n\n","category":"method"},{"location":"library/TPSCI/#FermiCG.tpsci_ci-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{ClusteredState{T,N,R},Any,FermiCG.ClusteredOperator}} where R where N where T","page":"TPSCI","title":"FermiCG.tpsci_ci","text":"tpsci_ci(ci_vector::ClusteredState{T,N,R}, cluster_ops, clustered_ham::ClusteredOperator;\n            thresh_cipsi = 1e-2,\n            thresh_foi   = 1e-6,\n            thresh_asci  = 1e-2,\n            max_iter     = 10,\n            conv_thresh  = 1e-4) where {T,N,R}\n\nRun TPSCI \n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/","page":"StringCI","title":"StringCI","text":"Pages = [\"StringCI.md\"]","category":"page"},{"location":"library/StringCI/#StringCI","page":"StringCI","title":"StringCI","text":"","category":"section"},{"location":"library/StringCI/","page":"StringCI","title":"StringCI","text":"Modules = [StringCI]\nPages   = [\"StringCI/StringCI.jl\", \"StringCI/DeterminantStrings.jl\", \"StringCI/FCI.jl\", \"StringCI/Helpers.jl\", \"StringCI/TDMs.jl\"]\nOrder   = [:module, :type, :function]\nDepth\t= 2","category":"page"},{"location":"library/StringCI/#FermiCG.StringCI","page":"StringCI","title":"FermiCG.StringCI","text":"Simple string-based CI code\n\n\n\n\n\n","category":"module"},{"location":"library/StringCI/#Base.copy!-Tuple{FermiCG.StringCI.DeterminantString,FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"Base.copy!","text":"Base.copy!(c1::DeterminantString,c2::DeterminantString)\n\ncopy c2 into c1\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.apply_annihilation!-Tuple{FermiCG.StringCI.DeterminantString,Int64}","page":"StringCI","title":"FermiCG.StringCI.apply_annihilation!","text":"apply_annihilation!(c::DeterminantString, orb_index::Int)\n\nApply an annihilation operator to c corresponding to orbital orb_index \n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.apply_creation!-Tuple{FermiCG.StringCI.DeterminantString,Int64}","page":"StringCI","title":"FermiCG.StringCI.apply_creation!","text":"apply_creation!(c::DeterminantString, orb_index::Int)\n\nApply a creation operator to c corresponding to orbital orb_index \n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index!-Tuple{FermiCG.StringCI.DeterminantString,Array{Int64,2}}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index!","text":"calc_linear_index!(c::DeterminantString, binomcoeff::Array{Int,2})\n\nCalculate the linear index, passing in binomial coefficient matrix makes it much faster\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index!-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index!","text":"calc_linear_index!(c::DeterminantString)\n\nCalculate the linear index\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_linear_index-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.calc_linear_index","text":"calc_linear_index(c::DeterminantString)\n\nReturn linear index for lexically ordered __config DeterminantString\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup","text":"fill_ca_lookup(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., calookup[Ka][c(p) + a(p)*np] = La\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup2-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup2","text":"fill_ca_lookup2(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., ca_lookup[Ka,p,q] = sign*La\n\n<L|p'q|K> = sign\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.fill_ca_lookup3-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.fill_ca_lookup3","text":"fill_ca_lookup3(c::DeterminantString)\n\nCreate an index table relating each DeterminantString with all ia substitutions i.e., ca_lookup[Ka,p,q] = (sign,La)\n\n<L|p'q|K> = sign\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_unoccupied!-Tuple{Array{Int64,1},FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.get_unoccupied!","text":"get_unoccupied(c::DeterminantString)\n\nget list of orbitals that are unoccupied\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_unoccupied-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.get_unoccupied","text":"get_unoccupied(c::DeterminantString)\n\nget list of orbitals that are unoccupied\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.reset!-Tuple{FermiCG.StringCI.DeterminantString}","page":"StringCI","title":"FermiCG.StringCI.reset!","text":"reset!(c::DeterminantString)\n\nReset the DeterminantString to the first config\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.build_H_matrix-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.build_H_matrix","text":"build_H_matrix(ints, P::FCIProblem)\n\nBuild the Hamiltonian defined by ints in the Slater Determinant Basis  in the sector of Fock space specified by P\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.build_S2_matrix-Tuple{FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.build_S2_matrix","text":"build_s2(prb::FCIProblem)\n\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms","text":"compute_ab_terms(v, H, P::FCIProblem, ket_a_lookup, ket_b_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms-Tuple{Any,Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms","text":"compute_ab_terms(v, H, P::FCIProblem)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms2-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms2","text":"compute_ab_terms2(v, H, P::FCIProblem, \n                      ket_a_lookup, ket_b_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms_full!-Tuple{Any,FermiCG.StringCI.FCIProblem,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms_full!","text":"compute_ab_terms_full!(H, P::FCIProblem, Hmat)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ab_terms_full-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.compute_ab_terms_full","text":"compute_ab_terms_full(H, P::FCIProblem)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_fock_diagonal-Tuple{FermiCG.StringCI.FCIProblem,Array{Float64,1},Float64}","page":"StringCI","title":"FermiCG.StringCI.compute_fock_diagonal","text":"compute_fock_diagonal!(H, P::FCIProblem, e_mf::Float64)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ss_terms2-Tuple{Any,Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_ss_terms2","text":"compute_aa_terms2(v, H, P::FCIProblem, \n                      ket_a_lookup)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_map-Tuple{Any,FermiCG.StringCI.FCIProblem,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.get_map","text":"get_map(ham, prb::FCIProblem, HdiagA, HdiagB)\n\nAssumes you've already computed the spin diagonal components\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_map-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.get_map","text":"get_map(ham, prb::FCIProblem)\n\nGet LinearMap with takes a vector and returns action of H on that vector\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.precompute_spin_diag_terms-Tuple{Any,FermiCG.StringCI.FCIProblem,Any}","page":"StringCI","title":"FermiCG.StringCI.precompute_spin_diag_terms","text":"precompute_spin_diag_terms(H, P::FCIProblem, e)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.run_fci-Tuple{Any,FermiCG.StringCI.FCIProblem}","page":"StringCI","title":"FermiCG.StringCI.run_fci","text":"run_fci(ints, prb::FCIProblem)\n\ninput: ints is a struct containing 0, 2, and 4 dimensional tensors\n\nh0: energy shift\nh1: 1 electron integrals\nh2: 2 electron integrals (chemists notation)\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\n\nints is simply an InCoreInts object from FermiCG\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.svd_state-Tuple{Any,FermiCG.StringCI.FCIProblem,Any,Any,Any}","page":"StringCI","title":"FermiCG.StringCI.svd_state","text":"svd_state(prb::FCIProblem)\n\nDo an SVD of the FCI vector partitioned into clusters with (norbs1 | norbs2) where the orbitals are assumed to be ordered for cluster 1| cluster 2 haveing norbs1 and  norbs2, respectively.\n\nprb: FCIProblem just defines the current CI problem (i.e., fock sector)\nnorbs1:number of orbitals in left cluster\nnorbs2:number of orbitals in right cluster\nsvd_thresh: the threshold below which the states will be discarded\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.calc_nchk-Tuple{Integer,Integer}","page":"StringCI","title":"FermiCG.StringCI.calc_nchk","text":"calc_nchk(n::Integer,k::Integer)\n\nCalculates binomial coefficient: n choose k\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.get_nchk-Tuple{Any,Any}","page":"StringCI","title":"FermiCG.StringCI.get_nchk","text":"get_nchk(n::Integer,k::Integer)\n\nLooks up binomial coefficient from a precomputed table: n choose k\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AA-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_AA","text":"compute_AA(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AAa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_AAa","text":"compute_AAa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_AB-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_AB","text":"compute_AB(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix)\n\nCompute representation of p'q' operators between states bra_v and ket_v, where p is alpha and q is beta.\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\n\nG(pqst) = v(IJs) <IJ|p'q'|KL> v(KLt) \n        = v(IJs) <J|<I|p'q'|K>|L> v(KLt)\n        = v(IJs) <J|<I|p'|K>q'|L> v(KLt) (-1)^N(K)\n        = v(IJs) <I|p'|K> <J|q'|L> v(KLt) (-1)^N(K)\n    \n        this can be vectorized if needed. for now:\n        loop over p,q\n            loop over K,L\n                sign = -1^N(K)\n                find indices of I,J\n                G(pq,st) += v(IJ,s) v(KL,t) * sign \n            end\n        end\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ABa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_ABa","text":"compute_ABa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta) giving ABa or BAb\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_ABb-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_ABb","text":"compute_ABb(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute represntation of 2creation operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta) giving ABa or BAb\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_Aa-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_Aa","text":"compute_Aa(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute representation of a'a operators between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_Ab-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T}","page":"StringCI","title":"FermiCG.StringCI.compute_Ab","text":"compute_Ab(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix)\n\nCompute representation of p'q operators between states bra_v and ket_v, where p is alpha and q is beta.\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\n\nG(pqst) = v(IJs) <IJ|p'q|KL> v(KLt) \n        = v(IJs) <J|<I|p'q|K>|L> v(KLt)\n        = v(IJs) <J|<I|p'|K>q|L> v(KLt) (-1)^N(K)\n        = v(IJs) <I|p'|K> <J|q|L> v(KLt) (-1)^N(K)\n    \n        this can be vectorized if needed. for now:\n        loop over p,q\n            loop over K,L\n                sign = -1^N(K)\n                find indices of I,J\n                G(pq,st) += v(IJ,s) v(KL,t) * sign \n            end\n        end\n\n\n\n\n\n","category":"method"},{"location":"library/StringCI/#FermiCG.StringCI.compute_annihilation-Tuple{Integer,Any,Any,Any,Any,Array{T,2} where T,Array{T,2} where T,Any}","page":"StringCI","title":"FermiCG.StringCI.compute_annihilation","text":"compute_annihilation(no::Integer, bra_na, bra_nb, ket_na, ket_nb, bra_v::Matrix, ket_v::Matrix, spin_case)\n\nCompute an creation operator between states bra_v and ket_v\n\nArguments\n\nno: number of orbitals\nbra_na: number of alpha electrons in bra\nbra_nb: number of beta electrons in bra\nket_na: number of alpha electrons in ket\nket_nb: number of beta electrons in ket\nbra_v: basis vectors in bra\nket_v: basis vectors ket\nspin_case: either (alpha|beta)\n\n\n\n\n\n","category":"method"},{"location":"library/Utils/","page":"Utils","title":"Utils","text":"Pages = [\"Utils.md\"]","category":"page"},{"location":"library/Utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"library/Utils/","page":"Utils","title":"Utils","text":"Modules = [FermiCG]\nPages   = [\"Utils.jl\"]\nOrder   = [:type, :function]\nDepth\t= 2","category":"page"},{"location":"library/Utils/#FermiCG.get_nchk-Tuple{Any,Any}","page":"Utils","title":"FermiCG.get_nchk","text":"replace this with table lookup\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FermiCG","category":"page"},{"location":"#FermiCG","page":"Home","title":"FermiCG","text":"","category":"section"},{"location":"library/public/#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"Documentation for FermiCG.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#FermiCG","page":"Public Documentation","title":"FermiCG","text":"","category":"section"},{"location":"library/public/","page":"Public Documentation","title":"Public Documentation","text":"Modules = [FermiCG]\nPages   = [\"FermiCG.jl\"]","category":"page"},{"location":"library/public/#FermiCG.FermiCG","page":"Public Documentation","title":"FermiCG.FermiCG","text":"General electronic course-graining platform\n\n\n\n\n\n","category":"module"}]
}
